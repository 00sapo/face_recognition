class KmeansBackgroundRemover
!!!132482.cpp!!!	KmeansBackgroundRemover(in fixedThreshold : uint16_t = 1600)
    // load the pretrained face detection model
    classifier = cv::CascadeClassifier(Settings::getInstance().getFaceDetectorPath());
    if (classifier.empty()) {
        std::cerr << "ERROR! Unable to load haarcascade_frontalface_default.xml" << std::endl;
        return;
    }

    faceDetectorAvailable = true;
!!!132610.cpp!!!	filter() : bool
    cv::Rect boundingBox;
    // ... detect foreground face...
    if (!detectForegroundFace(boundingBox))
        removeBackgroundFixed();
    else
        removeBackgroundDynamic(boundingBox);

    return 1;
!!!132738.cpp!!!	getImage4d() : Image4DSetComponent
    return image4d;
!!!132866.cpp!!!	setImage4d(inout value : Image4DSetComponent) : void
    image4d = value;
!!!132994.cpp!!!	getFixedThreshold() : uint16_t
    return fixedThreshold;
!!!133122.cpp!!!	setFixedThreshold(in value : uint16_t) : void
    fixedThreshold = value;
!!!133250.cpp!!!	getClassifier() : cv::CascadeClassifier
    return classifier;
!!!133378.cpp!!!	setClassifier(in value : cv::CascadeClassifier) : void
    classifier = value;
    faceDetectorAvailable = true;
!!!133506.cpp!!!	isFaceDetectorAvailable() : bool
    return faceDetectorAvailable;
!!!133634.cpp!!!	removeBackgroundFixed() : void
    uint16_t threshold = fixedThreshold;
    image4d->getDepthMap().forEach<uint16_t>([threshold](uint16_t& p, const int* pos) {
        if (p > threshold || std::isnan(p))
            p = 0;
    });

    return;
!!!133762.cpp!!!	removeBackgroundDynamic(inout boundingBox : cv::Rect) : void
    // take non-nan, non-zero points
    vector<float> depth;
    auto lambda = [&depth](int x, int y, const uint16_t& dpt) {
        if (!std::isnan(dpt) && dpt != 0)
            depth.push_back(dpt);
    };

    image4d->depthForEach<uint16_t>(lambda, boundingBox);

    // clustering
    vector<int> bestLabels;
    vector<float> centers;
    cv::TermCriteria criteria(cv::TermCriteria::EPS, 10, 1.0);
    cv::kmeans(depth, 2, bestLabels, criteria, 3, cv::KMEANS_PP_CENTERS, centers);

    if (centers.size() != 2) {
        std::cout << "Clustering on depth map for background removal failed!" << std::endl;
        return;
    }

    // compute threshold based on clustering
    const int FACE_CLUSTER = centers[0] < centers[1] ? 0 : 1;
    float threshold = centers[FACE_CLUSTER] * 1.2f;

    const int MIN_X = boundingBox.x - boundingBox.width;
    const int MAX_X = boundingBox.x + 2 * boundingBox.width;

    image4d->getDepthMap().forEach<uint16_t>([&](uint16_t& p, const int* pos) {
        if (float(p) > threshold || std::isnan(p) || pos[1] < MIN_X || pos[1] > MAX_X)
            p = 0;
    });

    return;
!!!133890.cpp!!!	detectForegroundFace(inout boundingBox : cv::Rect) : bool
    if (!faceDetectorAvailable) {
        std::cout << "Error! Face detector unavailable!" << std::endl;
        return false;
    }

    // face detection
    vector<cv::Rect> faces;
    classifier.detectMultiScale(image4d->getImage(), faces, 1.1, 2, 0 | cv::CASCADE_SCALE_IMAGE, cv::Size(70, 70));

    if (faces.empty())
        return false;

    // take face in foregound (the one with bigger bounding box)
    boundingBox = *std::max_element(faces.begin(), faces.end(),
        [](const cv::Rect& r1, const cv::Rect& r2) { return r1.area() < r2.area(); });

    return true;
