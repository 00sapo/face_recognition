class KmeansBackgroundRemover
!!!148482.cpp!!!	KmeansBackgroundRemover(in fixedThreshold : uint16_t = 1600)
    // load the pretrained face detection model
    classifier = cv::CascadeClassifier(Settings::getInstance().getFaceDetectorPath());
    if (classifier.empty()) {
        std::cerr << "ERROR! Unable to load haarcascade_frontalface_default.xml" << std::endl;
        return;
    }

    faceDetectorAvailable = true;
!!!148610.cpp!!!	filter() : bool
    if (image4d->isLeaf()) {
        cv::Rect boundingBox;
        // ... detect foreground face...
        if (!detectForegroundFace(boundingBox))
            removeBackgroundFixed();
        else
            removeBackgroundDynamic(boundingBox);

    } else {
        image4d->forEachComponent(filterImage4DComponent);
    }
    return 1;
!!!148738.cpp!!!	getImage4DComponent() : Image4DComponent
    return image4d;
!!!148866.cpp!!!	setImage4DComponent(inout value : Image4DComponent) : void
    image4d = value;
!!!148994.cpp!!!	getFixedThreshold() : uint16_t
    return fixedThreshold;
!!!149122.cpp!!!	setFixedThreshold(in value : uint16_t) : void
    fixedThreshold = value;
!!!149250.cpp!!!	getClassifier() : cv::CascadeClassifier
    return classifier;
!!!149378.cpp!!!	setClassifier(in value : cv::CascadeClassifier) : void
    classifier = value;
    faceDetectorAvailable = true;
!!!149506.cpp!!!	isFaceDetectorAvailable() : bool
    return faceDetectorAvailable;
!!!149634.cpp!!!	removeBackgroundFixed() : void
    uint16_t threshold = fixedThreshold;
    image4d->getDepthMap().forEach<uint16_t>([threshold](uint16_t& p, const int* pos) {
        if (p > threshold || std::isnan(p))
            p = 0;
    });

    return;
!!!149762.cpp!!!	removeBackgroundDynamic(inout boundingBox : cv::Rect) : void
    // take non-nan, non-zero points
    vector<float> depth;
    auto lambda = [&depth](int x, int y, boost::any& d) {
        uint16_t dpt = boost::any_cast<uint16_t>(d);
        if (!std::isnan(dpt) && dpt != 0)
            depth.push_back(dpt);
    };

    image4d->depthForEach(lambda, boundingBox);

    // clustering
    vector<int> bestLabels;
    vector<float> centers;
    cv::TermCriteria criteria(cv::TermCriteria::EPS, 10, 1.0);
    cv::kmeans(depth, 2, bestLabels, criteria, 3, cv::KMEANS_PP_CENTERS, centers);

    if (centers.size() != 2) {
        std::cout << "Clustering on depth map for background removal failed!" << std::endl;
        return;
    }

    // compute threshold based on clustering
    const int FACE_CLUSTER = centers[0] < centers[1] ? 0 : 1;
    float threshold = centers[FACE_CLUSTER] * 1.2f;

    const int MIN_X = boundingBox.x - boundingBox.width;
    const int MAX_X = boundingBox.x + 2 * boundingBox.width;

    image4d->getDepthMap().forEach<uint16_t>([&](uint16_t& p, const int* pos) {
        if (float(p) > threshold || std::isnan(p) || pos[1] < MIN_X || pos[1] > MAX_X)
            p = 0;
    });

    return;
!!!149890.cpp!!!	detectForegroundFace(inout boundingBox : cv::Rect) : bool
    if (!faceDetectorAvailable) {
        std::cout << "Error! Face detector unavailable!" << std::endl;
        return false;
    }

    // face detection
    vector<cv::Rect> faces;
    classifier.detectMultiScale(image4d->getImage(), faces, 1.1, 2, 0 | cv::CASCADE_SCALE_IMAGE, cv::Size(70, 70));

    if (faces.empty())
        return false;

    // take face in foregound (the one with bigger bounding box)
    boundingBox = *std::max_element(faces.begin(), faces.end(),
        [](const cv::Rect& r1, const cv::Rect& r2) { return r1.area() < r2.area(); });

    return true;
!!!150018.cpp!!!	filterImage4DComponent(inout image4d : Image4DComponent) : void
    KmeansBackgroundRemover remover;
    remover.setImage4DComponent(image4d);
    remover.filter();
