class CRTree
!!!130562.cpp!!!	loadTree(in filename : char) : bool


	cout << "Load Tree (BIN) " << filename << " " << flush;
	int dummy;
	bool success = true;

	FILE* fp = fopen(filename,"rb");

	if(!fp){
		cout << "failed" << endl;
		return false;
	}

	success &= ( fread( &max_depth, sizeof(int), 1, fp) == 1);
	success &= ( fread( &num_leaf, 	sizeof(int), 1, fp) == 1);
	success &= ( fread( &m_pwidth,  sizeof(int), 1, fp) == 1);
	success &= ( fread( &m_pheight, sizeof(int), 1, fp) == 1);
	success &= ( fread( &m_no_chans,sizeof(int), 1, fp) == 1);

	num_nodes = (int)pow(2.0,int(max_depth+1))-1;   // compute number of existing nodes

	treetable = new int[num_nodes * TEST_DIM];   // num_nodes x test size: [index, x1,y1,x2,y,2,w1,h1,w2,h2,channel,threshold]
	int* ptT = &treetable[0];                    // get pointer to the tree table

	// get number of leaves from text file
	leaf = new LeafNode[num_leaf];

	// read tree nodes
	for(unsigned int n=0; n<num_nodes; ++n) {

		success &= ( fread( &dummy,   sizeof(int), 1, fp) == 1);
		success &= ( fread( &dummy,   sizeof(int), 1, fp) == 1);

		//read in the test parameters
		for(unsigned int i=0; i<TEST_DIM; ++i, ++ptT){
			success &= ( fread( ptT, sizeof(int), 1, fp) == 1);
		}

	}

	// read tree leafs
	LeafNode* ptLN = &leaf[0];
	for(unsigned int l=0; l<num_leaf; ++l, ++ptLN) {

		ptLN->mean.create(POSE_SIZE, 1, CV_32FC1); ptLN->mean.setTo(0);

		success &= ( fread( &dummy,			sizeof(int), 1, fp) == 1);
		success &= ( fread( &(ptLN->pfg),    sizeof(float), 1, fp) == 1);
		success &= ( fread( ptLN->mean.data, sizeof(float), POSE_SIZE, fp) == POSE_SIZE );
		success &= ( fread( &(ptLN->trace),    sizeof(float), 1, fp) == 1);

	}

	fclose(fp);
	std::cout << " done " << endl;

	return success;

!!!131202.cpp!!!	regressionIntegral(in patch : std::vector< cv::Mat >, in nonZeros : cv::Mat, in roi : cv::Rect) : LeafNode


	// pointer to current node
	const int* pnode = &treetable[0];
	int node = 0;

	// Go through tree until one arrives at a leaf, i.e. pnode[0]>=0)
	while(pnode[0]==-1) {

		const cv::Mat ptC = patch[ pnode[9] ];

		int xa1 = roi.x + pnode[1];		int xa2 = xa1 + pnode[5];
		int ya1 = roi.y + pnode[2];		int ya2 = ya1 + pnode[6];
		int xb1 = roi.x + pnode[3];		int xb2 = xb1 + pnode[7];
		int yb1 = roi.y + pnode[4];		int yb2 = yb1 + pnode[8];

		double mz1 = ( ptC.at<double>(ya1,xa1) +
					   ptC.at<double>(ya2,xa2) -
					   ptC.at<double>(ya2,xa1) -
					   ptC.at<double>(ya1,xa2) )/
					   (double)MAX(1, nonZeros.at<double>(ya1,xa1) +
									  nonZeros.at<double>(ya2,xa2) -
									  nonZeros.at<double>(ya2,xa1) -
									  nonZeros.at<double>(ya1,xa2));

		double mz2 = ( ptC.at<double>(yb1,xb1) +
					   ptC.at<double>(yb2,xb2) -
					   ptC.at<double>(yb2,xb1) -
					   ptC.at<double>(yb1,xb2) )/
					   (double)MAX(1, nonZeros.at<double>(yb1,xb1) +
									  nonZeros.at<double>(yb2,xb2) -
									  nonZeros.at<double>(yb2,xb1) -
									  nonZeros.at<double>(yb1,xb2));

		//check test
		int test = ( (mz1 - mz2) >= (double)pnode[10] );

		//the test result sends the patch to one of the children nodes
		int incr = node+1+test;
		node += incr;
		pnode += incr*TEST_DIM;

	}

	return &leaf[pnode[0]];

